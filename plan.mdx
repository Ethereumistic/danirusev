Optimization Plan: The "Matrix" Architecture
Context: The current Products schema is functional but inefficient for products with multiple variants (e.g., Size + Color + Scent). The user experiences "inhumane" data entry friction. We need to implement a "Smart Variant System" that automates SKU generation, allows "Option-Level" image assignment (assign image to "Red" once, not 4 times), and uses a 2D-style Bulk Editor.

Core Objective: Minimize clicks. If a user adds "Color: Red" and "Size: S, M, L", they should only upload the Red image once.

1. Schema Architecture Refinements (Products.ts)
We need to modify the data structure to support "Smart Inheritance".

A. "Smart" Stock Field (Conditional Logic)
Goal: Hide the global stock field when variants exist to prevent confusion.

Implementation:

Move the top-level stock field into a conditional visibility rule.

admin: { condition: (data) => !data.options || data.options.length === 0 }

B. Enhanced options Array (The Key to Speed)
Goal: Allow defining metadata (Images, Hex Colors) at the definition level, not just the variant level.

Change: Convert the simple values array into an object array with metadata.

New Structure:

TypeScript

{
  name: 'options',
  type: 'array',
  fields: [
    { name: 'name', type: 'text' }, // e.g. "Color"
    {
      name: 'values',
      type: 'array',
      fields: [
        { name: 'label', type: 'text', required: true }, // e.g. "Red"
        { name: 'valueMetadata', type: 'group', fields: [
            { name: 'image', type: 'upload', relationTo: 'media' }, // "Red" image
            { name: 'hexColor', type: 'text' }, // Swatch color #FF0000
        ]}
      ]
    }
  ]
}
Why this wins: When the variants are generated, the system checks options.values. If "Red" has an image, all variants containing "Red" automatically inherit that image unless manually overridden.

C. The variants Field (The Bulk Editor)
Goal: Replace the standard Payload Array UI with a Custom Component (VariantManager).

Config:

TypeScript

{
  name: 'variants',
  type: 'array',
  admin: {
    components: {
      Field: '/components/VariantManager' // Custom React Component
    }
  },
  fields: [ ... ] // Keep existing fields (sku, stock, price, etc.)
}
2. The VariantManager Custom Component (React)
This is the most critical part of the build. Instruct the AI to build a component with these specific features:

Auto-Generation State:

Watch the options field.

Compute the Cartesian Product (Option 1 x Option 2 x Option 3).

Example: [Red, Blue] x [S, M] = 4 Rows.

Compare with existing variants. If new combinations exist, append them. If options are removed, flag/remove invalid variants.

The "Data Grid" UI:

Render a table, not a list of collapsible drawers.

Columns:

Variant Name (Read-only, e.g., "Red / S")

Price (Input - defaults to Product Base Price)

Stock (Input)

SKU (Input - displays auto-generated value placeholder)

Image (Thumbnail + Edit button)

Visual Logic:

The Image cell should show the "Inherited" image from the Option Definition (e.g., the Red Shirt) with an opacity marker. If the user uploads a specific image for this variant (e.g., Red/S has a specific logo), it overrides the inherited one and shows at full opacity.

Bulk Actions Toolbar:

"Apply Price to All"

"Apply Stock to All"

"Regenerate SKUs"

3. Automation Hooks (The "Robot")
Implement these beforeChange hooks in Products.ts to handle the data processing silently.

A. Auto-SKU Generator
Logic:

If sku is empty, generate it.

Format: SLUG-OPT1-OPT2.

Example: Product Slug: dr-11-beanie, Variant: Red/L -> SKU: DR-11-BEANIE-RED-L.

Sanitize: Uppercase, replace spaces with dashes.

B. Image Inheritance Resolution
Logic:

Iterate through variants.

If variant.image is empty, look up the options.

Find the matching Option Value (e.g., "Red").

If "Red" has a valueMetadata.image, save that ID into variant.image.

Result: The frontend doesn't need complex logic; the DB always has the correct image reference on the variant itself.

We are optimizing the 'Products' collection in Payload CMS v3.
Currently, the 'variants' array requires manual entry which is too slow.

Task: Implement a "Smart Variant System" with the following changes:

1. SCHEMA CHANGE (Products.ts):
   - Modify 'options.values' to be an array of objects: { label: string, image?: Upload, hex?: string }. This allows setting an image for "Red" once.
   - Make the global 'stock' field conditional: hidden if options.length > 0.
   - Add a 'lowStockThreshold' (number) field.

2. CUSTOM COMPONENT (VariantManager.tsx):
   - Create a React component to replace the default Array UI for 'variants'.
   - It should calculate the Cartesian product of 'options' to auto-generate rows.
   - Render a simplified Data Grid (Table) for quick entry of Stock and Price.
   - Logic: If a variant is "Red / S" and the user assigned an image to the "Red" option, this variant should visually inherit that image.

3. HOOKS (beforeChange):
   - Auto-generate SKUs for variants using the pattern: {PRODUCT_SLUG}-{OPT1}-{OPT2} (uppercase).
   - If a variant has no specific image set, copy the image from the matching Option Value (e.g. Color) into the variant's image field so the API response is complete.

4. FRONTEND TYPE SAFETY:
   - Update the Product interface to reflect that 'stock' might be on the parent OR the variant.
   - Update 'useProductStock' hook to handle these two sources of truth.