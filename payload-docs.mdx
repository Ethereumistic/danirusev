
Swap in your own React components
The Payload Admin Panel is designed to be as minimal and straightforward as possible to allow for easy customization and full control over the UI. In order for Payload to support this level of customization, Payload provides a pattern for you to supply your own React components through your Payload Config.

All Custom Components in Payload are React Server Components by default. This enables the use of the Local API directly on the front-end. Custom Components are available for nearly every part of the Admin Panel for extreme granularity and control.

Note: Client Components continue to be fully supported. To use Client Components in your app, simply include the 'use client' directive. Payload will automatically detect and remove all non-serializable default props before rendering your component. More details.

There are four main types of Custom Components in Payload:

Root Components
Collection Components
Global Components
Field Components
To swap in your own Custom Component, first determine the scope that corresponds to what you are trying to accomplish, consult the list of available components, then author your React component(s) accordingly.

Defining Custom Components
As Payload compiles the Admin Panel, it checks your config for Custom Components. When detected, Payload either replaces its own default component with yours, or if none exists by default, renders yours outright. While there are many places where Custom Components are supported in Payload, each is defined in the same way using Component Paths.

To add a Custom Component, point to its file path in your Payload Config:

import { buildConfig } from 'payload'

const config = buildConfig({
  // ...
  admin: {
    components: {
      logout: {
        Button: '/src/components/Logout#MyComponent', 
      },
    },
  },
})

---
Root Components
Root Components are those that affect the Admin Panel at a high-level, such as the logo or the main nav. You can swap out these components with your own Custom Components to create a completely custom look and feel.

When combined with Custom CSS, you can create a truly unique experience for your users, such as white-labeling the Admin Panel to match your brand.

To override Root Components, use the admin.components property at the root of your Payload Config:

import { buildConfig } from 'payload'

export default buildConfig({
  // ...
  admin: {
    components: {
      // ...
    },
  },
})
Config Options
The following options are available:

Path

Description

actions

An array of Custom Components to be rendered within the header of the Admin Panel, providing additional interactivity and functionality. More details.

afterDashboard

An array of Custom Components to inject into the built-in Dashboard, after the default dashboard contents. More details.

afterLogin

An array of Custom Components to inject into the built-in Login, after the default login form. More details.

afterNavLinks

An array of Custom Components to inject into the built-in Nav, after the links. More details.

beforeDashboard

An array of Custom Components to inject into the built-in Dashboard, before the default dashboard contents. More details.

beforeLogin

An array of Custom Components to inject into the built-in Login, before the default login form. More details.

beforeNavLinks

An array of Custom Components to inject into the built-in Nav, before the links themselves. More details.

graphics.Icon

The simplified logo used in contexts like the Nav component. More details.

graphics.Logo

The full logo used in contexts like the Login view. More details.

header

An array of Custom Components to be injected above the Payload header. More details.

logout.Button

The button displayed in the sidebar that logs the user out. More details.

Nav

Contains the sidebar / mobile menu in its entirety. More details.

settingsMenu

An array of Custom Components to inject into a popup menu accessible via a gear icon above the logout button. More details.

providers

Custom React Context providers that will wrap the entire Admin Panel. More details.

views

Override or create new views within the Admin Panel. More details.

For details on how to build Custom Components, see Building Custom Components.

Note: You can also set Collection Components and Global Components in their respective configs.

Components
actions
Actions are rendered within the header of the Admin Panel. Actions are typically used to display buttons that add additional interactivity and functionality, although they can be anything you'd like.

To add an action, use the actions property in your admin.components config:

import { buildConfig } from 'payload'

export default buildConfig({
  // ...
  admin: {
    components: {
      actions: ['/path/to/your/component'],
    },
  },
})
Here is an example of a simple Action component:

export default function MyCustomAction() {
  return (
    <button onClick={() => alert('Hello, world!')}>
      This is a custom action component
    </button>
  )
}
Note: You can also use add Actions to the Edit View and List View in their respective configs.

beforeDashboard
The beforeDashboard property allows you to inject Custom Components into the built-in Dashboard, before the default dashboard contents.

To add beforeDashboard components, use the admin.components.beforeDashboard property in your Payload Config:

import { buildConfig } from 'payload'

export default buildConfig({
  // ...
  admin: {
    components: {
      beforeDashboard: ['/path/to/your/component'],
    },
  },
})
Here is an example of a simple beforeDashboard component:

export default function MyBeforeDashboardComponent() {
  return <div>This is a custom component injected before the Dashboard.</div>
}
afterDashboard
Similar to beforeDashboard, the afterDashboard property allows you to inject Custom Components into the built-in Dashboard, after the default dashboard contents.

To add afterDashboard components, use the admin.components.afterDashboard property in your Payload Config:

import { buildConfig } from 'payload'

export default buildConfig({
  // ...
  admin: {
    components: {
      afterDashboard: ['/path/to/your/component'],
    },
  },
})
Here is an example of a simple afterDashboard component:

export default function MyAfterDashboardComponent() {
  return <div>This is a custom component injected after the Dashboard.</div>
}
beforeLogin
The beforeLogin property allows you to inject Custom Components into the built-in Login view, before the default login form.

To add beforeLogin components, use the admin.components.beforeLogin property in your Payload Config:

import { buildConfig } from 'payload'

export default buildConfig({
  // ...
  admin: {
    components: {
      beforeLogin: ['/path/to/your/component'],
    },
  },
})
Here is an example of a simple beforeLogin component:

export default function MyBeforeLoginComponent() {
  return <div>This is a custom component injected before the Login form.</div>
}
afterLogin
Similar to beforeLogin, the afterLogin property allows you to inject Custom Components into the built-in Login view, after the default login form.

To add afterLogin components, use the admin.components.afterLogin property in your Payload Config:

import { buildConfig } from 'payload'

export default buildConfig({
  // ...
  admin: {
    components: {
      afterLogin: ['/path/to/your/component'],
    },
  },
})
Here is an example of a simple afterLogin component:

export default function MyAfterLoginComponent() {
  return <div>This is a custom component injected after the Login form.</div>
}
beforeNavLinks
The beforeNavLinks property allows you to inject Custom Components into the built-in Nav Component, before the nav links themselves.

To add beforeNavLinks components, use the admin.components.beforeNavLinks property in your Payload Config:

import { buildConfig } from 'payload'

export default buildConfig({
  // ...
  admin: {
    components: {
      beforeNavLinks: ['/path/to/your/component'],
    },
  },
})
Here is an example of a simple beforeNavLinks component:

export default function MyBeforeNavLinksComponent() {
  return <div>This is a custom component injected before the Nav links.</div>
}
afterNavLinks
Similar to beforeNavLinks, the afterNavLinks property allows you to inject Custom Components into the built-in Nav, after the nav links.

To add afterNavLinks components, use the admin.components.afterNavLinks property in your Payload Config:

import { buildConfig } from 'payload'

export default buildConfig({
  // ...
  admin: {
    components: {
      afterNavLinks: ['/path/to/your/component'],
    },
  },
})
Here is an example of a simple afterNavLinks component:

export default function MyAfterNavLinksComponent() {
  return <p>This is a custom component injected after the Nav links.</p>
}
settingsMenu
The settingsMenu property allows you to inject Custom Components into a popup menu accessible via a gear icon in the navigation controls, positioned above the logout button. This is ideal for adding custom actions, utilities, or settings that are relevant at the admin level.

To add settingsMenu components, use the admin.components.settingsMenu property in your Payload Config:

import { buildConfig } from 'payload'

export default buildConfig({
  // ...
  admin: {
    components: {
      settingsMenu: ['/path/to/your/component#ComponentName'],
    },
  },
})
Here is an example of a simple settingsMenu component:

'use client'
import { PopupList } from '@payloadcms/ui'

export function MySettingsMenu() {
  return (
    <PopupList.ButtonGroup>
      <PopupList.Button onClick={() => console.log('Action triggered')}>
        Custom Action
      </PopupList.Button>
      <PopupList.Button onClick={() => window.open('/admin/custom-page')}>
        Custom Page
      </PopupList.Button>
    </PopupList.ButtonGroup>
  )
}
You can pass multiple components to create organized groups of menu items:

import { buildConfig } from 'payload'

export default buildConfig({
  // ...
  admin: {
    components: {
      settingsMenu: [
        '/components/SystemActions#SystemActions',
        '/components/DataManagement#DataManagement',
      ],
    },
  },
})
Nav
The Nav property contains the sidebar / mobile menu in its entirety. Use this property to completely replace the built-in Nav with your own custom navigation.

To add a custom nav, use the admin.components.Nav property in your Payload Config:

import { buildConfig } from 'payload'

export default buildConfig({
  // ...
  admin: {
    components: {
      Nav: '/path/to/your/component',
    },
  },
})
Here is an example of a simple Nav component:

import { Link } from '@payloadcms/ui'

export default function MyCustomNav() {
  return (
    <nav>
      <ul>
        <li>
          <Link href="/dashboard">Dashboard</Link>
        </li>
      </ul>
    </nav>
  )
}
graphics.Icon
The Icon property is the simplified logo used in contexts like the Nav component. This is typically a small, square icon that represents your brand.

To add a custom icon, use the admin.components.graphics.Icon property in your Payload Config:

import { buildConfig } from 'payload'

export default buildConfig({
  // ...
  admin: {
    components: {
      graphics: {
        Icon: '/path/to/your/component',
      },
    },
  },
})
Here is an example of a simple Icon component:

export default function MyCustomIcon() {
  return <img src="/path/to/your/icon.png" alt="My Custom Icon" />
}
graphics.Logo
The Logo property is the full logo used in contexts like the Login view. This is typically a larger, more detailed representation of your brand.

To add a custom logo, use the admin.components.graphics.Logo property in your Payload Config:

import { buildConfig } from 'payload'

export default buildConfig({
  // ...
  admin: {
    components: {
      graphics: {
        Logo: '/path/to/your/component',
      },
    },
  },
})
Here is an example of a simple Logo component:

export default function MyCustomLogo() {
  return <img src="/path/to/your/logo.png" alt="My Custom Logo" />
}
header
The header property allows you to inject Custom Components above the Payload header.

Examples of a custom header components might include an announcements banner, a notifications bar, or anything else you'd like to display at the top of the Admin Panel in a prominent location.

To add header components, use the admin.components.header property in your Payload Config:

import { buildConfig } from 'payload'

export default buildConfig({
  // ...
  admin: {
    components: {
      header: ['/path/to/your/component'],
    },
  },
})
Here is an example of a simple header component:

export default function MyCustomHeader() {
  return (
    <header>
      <h1>My Custom Header</h1>
    </header>
  )
}
logout.Button
The logout.Button property is the button displayed in the sidebar that should log the user out when clicked.

To add a custom logout button, use the admin.components.logout.Button property in your Payload Config:

import { buildConfig } from 'payload'

export default buildConfig({
  // ...
  admin: {
    components: {
      logout: {
        Button: '/path/to/your/component',
      },
    },
  },
})
Here is an example of a simple logout.Button component:

export default function MyCustomLogoutButton() {
  return <button onClick={() => alert('Logging out!')}>Log Out</button>
}
---

Swap in your own React Context providers
As you add more and more Custom Components to your Admin Panel, you may find it helpful to add additional React Context(s) to your app. Payload allows you to inject your own context providers where you can export your own custom hooks, etc.

To add a Custom Provider, use the admin.components.providers property in your Payload Config:

import { buildConfig } from 'payload'

export default buildConfig({
  // ...
  admin: {
    components: {
      providers: ['/path/to/MyProvider'], 
    },
  },
})
Then build your Custom Provider as follows:

'use client'
import React, { createContext, use } from 'react'

const MyCustomContext = React.createContext(myCustomValue)

export function MyProvider({ children }: { children: React.ReactNode }) {
  return <MyCustomContext value={myCustomValue}>{children}</MyCustomContext>
}

export const useMyCustomContext = () => use(MyCustomContext)
For details on how to build Custom Components, see Building Custom Components.

Reminder: React Context exists only within Client Components. This means they must include the use client directive at the top of their files and cannot contain server-only code. To use a Server Component here, simply wrap your Client Component with it.
---

Customizing Views
Views are the individual pages that make up the Admin Panel, such as the Dashboard, List View, and Edit View. One of the most powerful ways to customize the Admin Panel is to create Custom Views. These are Custom Components that can either replace built-in views or be entirely new.

There are four types of views within the Admin Panel:

Root Views
Collection Views
Global Views
Document Views
To swap in your own Custom View, first determine the scope that corresponds to what you are trying to accomplish, consult the list of available components, then author your React component(s) accordingly.

Configuration
Replacing Views
To customize views, use the admin.components.views property in your Payload Config. This is an object with keys for each view you want to customize. Each key corresponds to the view you want to customize.

The exact list of available keys depends on the scope of the view you are customizing, depending on whether it's a Root View, Collection View, or Global View. Regardless of the scope, the principles are the same.

Here is an example of how to swap out a built-in view:

import { buildConfig } from 'payload'

const config = buildConfig({
  // ...
  admin: {
    components: {
      views: {
        dashboard: {
          Component: '/path/to/MyCustomDashboard',
        },
      },
    },
  },
})
For more granular control, pass a configuration object instead. Payload exposes the following properties for each view:

Property

Description

Component *

Pass in the component path that should be rendered when a user navigates to this route.

path *

Any valid URL path or array of paths that path-to-regexp understands. Must begin with a forward slash (/).

exact

Boolean. When true, will only match if the path matches the usePathname() exactly.

strict

When true, a path that has a trailing slash will only match a location.pathname with a trailing slash. This has no effect when there are additional URL segments in the pathname.

sensitive

When true, will match if the path is case sensitive.

meta

Page metadata overrides to apply to this view within the Admin Panel. More details.

* An asterisk denotes that a property is required.

Adding New Views
To add a new view to the Admin Panel, simply add your own key to the views object. This is true for all view scopes.

New views require at least the Component and path properties:

import { buildConfig } from 'payload'

const config = buildConfig({
  // ...
  admin: {
    components: {
      views: {
        myCustomView: {
          Component: '/path/to/MyCustomView#MyCustomViewComponent',
          path: '/my-custom-view',
        },
      },
    },
  },
})
Note: Routes are cascading, so unless explicitly given the exact property, they will match on URLs that simply start with the route's path. This is helpful when creating catch-all routes in your application. Alternatively, define your nested route before your parent route.

Building Custom Views
Custom Views are simply Custom Components rendered at the page-level. Custom Views can either replace existing views or add entirely new ones. The process is generally the same regardless of the type of view you are customizing.

To understand how to build Custom Views, first review the Building Custom Components guide. Once you have a Custom Component ready, you can use it as a Custom View.

import type { CollectionConfig } from 'payload'

export const MyCollectionConfig: CollectionConfig = {
  // ...
  admin: {
    components: {
      views: {
        edit: {
          Component: '/path/to/MyCustomView', 
        },
      },
    },
  },
}
Default Props
Your Custom Views will be provided with the following props:

Prop

Description

initPageResult

An object containing req, payload, permissions, etc.

clientConfig

The Client Config object. More details.

importMap

The import map object.

params

An object containing the Dynamic Route Parameters.

searchParams

An object containing the Search Parameters.

doc

The document being edited. Only available in Document Views. More details.

i18n

The i18n object.

payload

The Payload class.

Note: Some views may receive additional props, such as Collection Views and Global Views. See the relevant section for more details.

Here is an example of a Custom View component:

import type { AdminViewServerProps } from 'payload'

import { Gutter } from '@payloadcms/ui'
import React from 'react'

export function MyCustomView(props: AdminViewServerProps) {
  return (
    <Gutter>
      <h1>Custom Default Root View</h1>
      <p>This view uses the Default Template.</p>
    </Gutter>
  )
}
Tip: For consistent layout and navigation, you may want to wrap your Custom View with one of the built-in Templates.

View Templates
Your Custom Root Views can optionally use one of the templates that Payload provides. The most common of these is the Default Template which provides the basic layout and navigation.

Here is an example of how to use the Default Template in your Custom View:

import type { AdminViewServerProps } from 'payload'

import { DefaultTemplate } from '@payloadcms/next/templates'
import { Gutter } from '@payloadcms/ui'
import React from 'react'

export function MyCustomView({
  initPageResult,
  params,
  searchParams,
}: AdminViewServerProps) {
  return (
    <DefaultTemplate
      i18n={initPageResult.req.i18n}
      locale={initPageResult.locale}
      params={params}
      payload={initPageResult.req.payload}
      permissions={initPageResult.permissions}
      searchParams={searchParams}
      user={initPageResult.req.user || undefined}
      visibleEntities={initPageResult.visibleEntities}
    >
      <Gutter>
        <h1>Custom Default Root View</h1>
        <p>This view uses the Default Template.</p>
      </Gutter>
    </DefaultTemplate>
  )
}
Securing Custom Views
All Custom Views are public by default. It's up to you to secure your custom views. If your view requires a user to be logged in or to have certain access rights, you should handle that within your view component yourself.

Here is how you might secure a Custom View:

import type { AdminViewServerProps } from 'payload'

import { Gutter } from '@payloadcms/ui'
import React from 'react'

export function MyCustomView({ initPageResult }: AdminViewServerProps) {
  const {
    req: { user },
  } = initPageResult

  if (!user) {
    return <p>You must be logged in to view this page.</p>
  }

  return (
    <Gutter>
      <h1>Custom Default Root View</h1>
      <p>This view uses the Default Template.</p>
    </Gutter>
  )
}
Root Views
Root Views are the main views of the Admin Panel. These are views that are scoped directly under the /admin route, such as the Dashboard or Account views.

To swap out Root Views with your own, or to create entirely new ones, use the admin.components.views property at the root of your Payload Config:

import { buildConfig } from 'payload'

const config = buildConfig({
  // ...
  admin: {
    components: {
      views: {
        dashboard: {
          Component: '/path/to/Dashboard',
        },
        // Other options include:
        // - account
        // - [key: string]
        // See below for more details
      },
    },
  },
})
For details on how to build Custom Views, including all available props, see Building Custom Views.

The following options are available:

Property

Description

account

The Account view is used to show the currently logged in user's Account page.

dashboard

The main landing page of the Admin Panel.

[key]

Any other key can be used to add a completely new Root View. More details.

Collection Views
Collection Views are views that are scoped under the /collections route, such as the Collection List and Document Edit views.

To swap out Collection Views with your own, or to create entirely new ones, use the admin.components.views property of your Collection Config:

import type { CollectionConfig } from 'payload'

export const MyCollectionConfig: CollectionConfig = {
  // ...
  admin: {
    components: {
      views: {
        edit: {
          default: {
            Component: '/path/to/MyCustomCollectionView',
          },
        },
        // Other options include:
        // - list
        // - [key: string]
        // See below for more details
      },
    },
  },
}
Reminder: The edit key is comprised of various nested views, known as Document Views, that relate to the same Collection Document. More details.

The following options are available:

Property

Description

edit

The Edit View corresponds to a single Document for any given Collection and consists of various nested views. More details.

list

The List View is used to show a list of Documents for any given Collection. More details.

[key]

Any other key can be used to add a completely new Collection View. More details.

For details on how to build Custom Views, including all available props, see Building Custom Views.

Global Views
Global Views are views that are scoped under the /globals route, such as the Edit View.

To swap out Global Views with your own or create entirely new ones, use the admin.components.views property in your Global Config:

import type { SanitizedGlobalConfig } from 'payload'

export const MyGlobalConfig: SanitizedGlobalConfig = {
  // ...
  admin: {
    components: {
      views: {
        edit: {
          default: {
            Component: '/path/to/MyCustomGlobalView',
          },
        },
        // Other options include:
        // - [key: string]
        // See below for more details
      },
    },
  },
}
Reminder: The edit key is comprised of various nested views, known as Document Views, that relate to the same Global Document. More details.

The following options are available:

Property

Description

edit

The Edit View represents a single Document for any given Global and consists of various nested views. More details.

[key]

Any other key can be used to add a completely new Global View. More details.

For details on how to build Custom Views, including all available props, see Building Custom Views.
---

Document Views
Document Views consist of multiple, individual views that together represent any single Collection or Global Document. All Document Views are scoped under the /collections/:collectionSlug/:id or the /globals/:globalSlug route, respectively.

There are a number of default Document Views, such as the Edit View and API View, but you can also create entirely new views as needed. All Document Views share a layout and can be given their own tab-based navigation, if desired.

To customize Document Views, use the admin.components.views.edit[key] property in your Collection Config or Global Config:

import type { CollectionConfig } from 'payload'

export const MyCollectionOrGlobalConfig: CollectionConfig = {
  // ...
  admin: {
    components: {
      views: {
        edit: {
          default: {
            Component: '/path/to/MyCustomEditView',
          },
          // Other options include:
          // - root
          // - api
          // - versions
          // - version
          // - [key: string]
          // See below for more details
        },
      },
    },
  },
}
Config Options
The following options are available:

Property

Description

root

The Root View overrides all other nested views and routes. No document controls or tabs are rendered when this key is set. More details.

default

The Default View is the primary view in which your document is edited. It is rendered within the "Edit" tab. More details.

versions

The Versions View is used to navigate the version history of a single document. It is rendered within the "Versions" tab. More details.

version

The Version View is used to edit a single version of a document. It is rendered within the "Version" tab. More details.

api

The API View is used to display the REST API JSON response for a given document. It is rendered within the "API" tab.

livePreview

The LivePreview view is used to display the Live Preview interface. It is rendered within the "Live Preview" tab. More details.

[key]

Any other key can be used to add a completely new Document View.

For details on how to build Custom Views, including all available props, see Building Custom Views.

Document Root
The Document Root is mounted on the top-level route for a Document. Setting this property will completely take over the entire Document View layout, including the title, Document Tabs, and all other nested Document Views including the Edit View, API View, etc.

When setting a Document Root, you are responsible for rendering all necessary components and controls, as no document controls or tabs would be rendered. To replace only the Edit View precisely, use the edit.default key instead.

To override the Document Root, use the views.edit.root property in your Collection Config or Global Config:

import type { CollectionConfig } from 'payload'

export const MyCollection: CollectionConfig = {
  slug: 'my-collection',
  admin: {
    components: {
      views: {
        edit: {
          root: {
            Component: '/path/to/MyCustomRootComponent', 
          },
        },
      },
    },
  },
}
Edit View
The Edit View is where users interact with individual Collection and Global Documents. This is where they can view, edit, and save their content. The Edit View is keyed under the default property in the views.edit object.

For more information on customizing the Edit View, see the Edit View documentation.

Document Tabs
Each Document View can be given a tab for navigation, if desired. Tabs are highly configurable, from as simple as changing the label to swapping out the entire component, they can be modified in any way.

To add or customize tabs in the Document View, use the views.edit.[key].tab property in your Collection Config or Global Config:

import type { CollectionConfig } from 'payload'

export const MyCollection: CollectionConfig = {
  slug: 'my-collection',
  admin: {
    components: {
      views: {
        edit: {
          myCustomView: {
            Component: '/path/to/MyCustomView',
            path: '/my-custom-tab',
            tab: {
              Component: '/path/to/MyCustomTabComponent',
            },
          },
          anotherCustomView: {
            Component: '/path/to/AnotherCustomView',
            path: '/another-custom-view',
            tab: {
              label: 'Another Custom View',
              href: '/another-custom-view',
              order: '100',
            },
          },
        },
      },
    },
  },
}
Note: This applies to both Collections and Globals.

The following options are available for tabs:

Property

Description

label

The label to display in the tab.

href

The URL to navigate to when the tab is clicked. This is optional and defaults to the tab's path.

order

The order in which the tab appears in the navigation. Can be set on default and custom tabs.

Component

The component to render in the tab. This can be a Server or Client component. More details

Tab Components
If changing the label or href is not enough, you can also replace the entire tab component with your own custom component. This can be done by setting the tab.Component property to the path of your custom component.

Here is an example of how to scaffold a custom Document Tab:

Server Component
import React from 'react'
import type { DocumentTabServerProps } from 'payload'
import { Link } from '@payloadcms/ui'

export function MyCustomTabComponent(props: DocumentTabServerProps) {
  return (
    <Link href="/my-custom-tab">This is a custom Document Tab (Server)</Link>
  )
}
Client Component
'use client'
import React from 'react'
import type { DocumentTabClientProps } from 'payload'
import { Link } from '@payloadcms/ui'

export function MyCustomTabComponent(props: DocumentTabClientProps) {
  return (
    <Link href="/my-custom-tab">This is a custom Document Tab (Client)</Link>
  )
}
---
Edit View
The Edit View is where users interact with individual Collection and Global Documents within the Admin Panel. The Edit View contains the actual form that submits the data to the server. This is where they can view, edit, and save their content. It contains controls for saving, publishing, and previewing the document, all of which can be customized to a high degree.

The Edit View can be swapped out in its entirety for a Custom View, or it can be injected with a number of Custom Components to add additional functionality or presentational elements without replacing the entire view.

Note: The Edit View is one of many Document Views in the Payload Admin Panel. Each Document View is responsible for a different aspect of interacting with a single Document.

Custom Edit View
To swap out the entire Edit View with a Custom View, use the views.edit.default property in your Collection Config or Global Config:

import { buildConfig } from 'payload'

const config = buildConfig({
  // ...
  admin: {
    components: {
      views: {
        edit: {
          default: {
            Component: '/path/to/MyCustomEditViewComponent',
          },
        },
      },
    },
  },
})
Here is an example of a custom Edit View:

Server Component
import React from 'react'
import type { DocumentViewServerProps } from 'payload'

export function MyCustomServerEditView(props: DocumentViewServerProps) {
  return <div>This is a custom Edit View (Server)</div>
}
Client Component
'use client'
import React from 'react'
import type { DocumentViewClientProps } from 'payload'

export function MyCustomClientEditView(props: DocumentViewClientProps) {
  return <div>This is a custom Edit View (Client)</div>
}
For details on how to build Custom Views, including all available props, see Building Custom Views.

Custom Components
In addition to swapping out the entire Edit View with a Custom View, you can also override individual components. This allows you to customize specific parts of the Edit View without swapping out the entire view.

Important: Collection and Globals are keyed to a different property in the admin.components object and have slightly different options. Be sure to use the correct key for the entity you are working with.

Collections
To override Edit View components for a Collection, use the admin.components.edit property in your Collection Config:

import type { CollectionConfig } from 'payload'

export const MyCollection: CollectionConfig = {
  // ...
  admin: {
    components: {
      edit: {
        // ...
      },
    },
  },
}
The following options are available:

Path

Description

beforeDocumentControls

Inject custom components before the Save / Publish buttons. More details.

editMenuItems

Inject custom components within the 3-dot menu dropdown located in the document control bar. More details.

SaveButton

A button that saves the current document. More details.

SaveDraftButton

A button that saves the current document as a draft. More details.

PublishButton

A button that publishes the current document. More details.

PreviewButton

A button that previews the current document. More details.

Description

A description of the Collection. More details.

Upload

A file upload component. More details.

Globals
To override Edit View components for Globals, use the admin.components.elements property in your Global Config:

import type { GlobalConfig } from 'payload'

export const MyGlobal: GlobalConfig = {
  // ...
  admin: {
    components: {
      elements: {
        // ...
      },
    },
  },
}
The following options are available:

Path

Description

beforeDocumentControls

Inject custom components before the Save / Publish buttons. More details.

editMenuItems

Inject custom components within the 3-dot menu dropdown located in the document control bar. More details.

SaveButton

A button that saves the current document. More details.

SaveDraftButton

A button that saves the current document as a draft. More details.

PublishButton

A button that publishes the current document. More details.

PreviewButton

A button that previews the current document. More details.

Description

A description of the Global. More details.

SaveButton
The SaveButton property allows you to render a custom Save Button in the Edit View.

To add a SaveButton component, use the components.edit.SaveButton property in your Collection Config or components.elements.SaveButton in your Global Config:

import type { CollectionConfig } from 'payload'

export const MyCollection: CollectionConfig = {
  // ...
  admin: {
    components: {
      edit: {
        SaveButton: '/path/to/MySaveButton',
      },
    },
  },
}
Here's an example of a custom SaveButton component:

Server Component
import React from 'react'
import { SaveButton } from '@payloadcms/ui'
import type { SaveButtonServerProps } from 'payload'

export function MySaveButton(props: SaveButtonServerProps) {
  return <SaveButton label="Save" />
}
Client Component
'use client'
import React from 'react'
import { SaveButton } from '@payloadcms/ui'
import type { SaveButtonClientProps } from 'payload'

export function MySaveButton(props: SaveButtonClientProps) {
  return <SaveButton label="Save" />
}
beforeDocumentControls
The beforeDocumentControls property allows you to render custom components just before the default document action buttons (like Save, Publish, or Preview). This is useful for injecting custom buttons, status indicators, or any other UI elements before the built-in controls.

To add beforeDocumentControls components, use the components.edit.beforeDocumentControls property in your Collection Config or components.elements.beforeDocumentControls in your Global Config:

Collections
export const MyCollection: CollectionConfig = {
  admin: {
    components: {
      edit: {
        beforeDocumentControls: ['/path/to/CustomComponent'],
      },
    },
  },
}
Globals
export const MyGlobal: GlobalConfig = {
  admin: {
    components: {
      elements: {
        beforeDocumentControls: ['/path/to/CustomComponent'],
      },
    },
  },
}
Here's an example of a custom beforeDocumentControls component:

Server Component
import React from 'react'
import type { BeforeDocumentControlsServerProps } from 'payload'

export function MyCustomDocumentControlButton(
  props: BeforeDocumentControlsServerProps,
) {
  return <div>This is a custom beforeDocumentControl button (Server)</div>
}
Client Component
'use client'
import React from 'react'
import type { BeforeDocumentControlsClientProps } from 'payload'

export function MyCustomDocumentControlButton(
  props: BeforeDocumentControlsClientProps,
) {
  return <div>This is a custom beforeDocumentControl button (Client)</div>
}
editMenuItems
The editMenuItems property allows you to inject custom components into the 3-dot menu dropdown located in the document controls bar. This dropdown contains default options including Create New, Duplicate, Delete, and other options when additional features are enabled. Any custom components you add will appear below these default items.

To add editMenuItems, use the components.edit.editMenuItems property in your Collection Config:

Config Example
import type { CollectionConfig } from 'payload'

export const Pages: CollectionConfig = {
  slug: 'pages',
  admin: {
    components: {
      edit: {
        editMenuItems: ['/path/to/CustomEditMenuItem'],
      },
    },
  },
}
Here's an example of a custom editMenuItems component:

Server Component
import React from 'react'

import type { EditMenuItemsServerProps } from 'payload'

export const EditMenuItems = async (props: EditMenuItemsServerProps) => {
  const href = `/custom-action?id=${props.id}`

  return (
    <>
      <a href={href}>Custom Edit Menu Item</a>
      <a href={href}>
        Another Custom Edit Menu Item - add as many as you need!
      </a>
    </>
  )
}
Client Component
'use client'

import React from 'react'
import { PopupList } from '@payloadcms/ui'

import type { EditViewMenuItemClientProps } from 'payload'

export const EditMenuItems = (props: EditViewMenuItemClientProps) => {
  const handleClick = () => {
    console.log('Custom button clicked!')
  }

  return (
    <PopupList.ButtonGroup>
      <PopupList.Button onClick={handleClick}>
        Custom Edit Menu Item
      </PopupList.Button>
      <PopupList.Button onClick={handleClick}>
        Another Custom Edit Menu Item - add as many as you need!
      </PopupList.Button>
    </PopupList.ButtonGroup>
  )
}
Styling: Use Payload's built-in PopupList.Button to ensure your menu items automatically match the default dropdown styles. If you want a different look, you can customize the appearance by passing your own className to PopupList.Button, or use a completely custom button built with a standard HTML button element or any other component that fits your design preferences.

SaveDraftButton
The SaveDraftButton property allows you to render a custom Save Draft Button in the Edit View.

To add a SaveDraftButton component, use the components.edit.SaveDraftButton property in your Collection Config or components.elements.SaveDraftButton in your Global Config:

import type { CollectionConfig } from 'payload'

export const MyCollection: CollectionConfig = {
  // ...
  admin: {
    components: {
      edit: {
        SaveDraftButton: '/path/to/MySaveDraftButton',
      },
    },
  },
}
Here's an example of a custom SaveDraftButton component:

Server Component
import React from 'react'
import { SaveDraftButton } from '@payloadcms/ui'
import type { SaveDraftButtonServerProps } from 'payload'

export function MySaveDraftButton(props: SaveDraftButtonServerProps) {
  return <SaveDraftButton />
}
Client Component
'use client'
import React from 'react'
import { SaveDraftButton } from '@payloadcms/ui'
import type { SaveDraftButtonClientProps } from 'payload'

export function MySaveDraftButton(props: SaveDraftButtonClientProps) {
  return <SaveDraftButton />
}
PublishButton
The PublishButton property allows you to render a custom Publish Button in the Edit View.

To add a PublishButton component, use the components.edit.PublishButton property in your Collection Config or components.elements.PublishButton in your Global Config:

import type { CollectionConfig } from 'payload'

export const MyCollection: CollectionConfig = {
  // ...
  admin: {
    components: {
      edit: {
        PublishButton: '/path/to/MyPublishButton',
      },
    },
  },
}
Here's an example of a custom PublishButton component:

Server Component
import React from 'react'
import { PublishButton } from '@payloadcms/ui'
import type { PublishButtonClientProps } from 'payload'

export function MyPublishButton(props: PublishButtonServerProps) {
  return <PublishButton label="Publish" />
}
Client Component
'use client'
import React from 'react'
import { PublishButton } from '@payloadcms/ui'
import type { PublishButtonClientProps } from 'payload'

export function MyPublishButton(props: PublishButtonClientProps) {
  return <PublishButton label="Publish" />
}
PreviewButton
The PreviewButton property allows you to render a custom Preview Button in the Edit View.

To add a PreviewButton component, use the components.edit.PreviewButton property in your Collection Config or components.elements.PreviewButton in your Global Config:

import type { CollectionConfig } from 'payload'

export const MyCollection: CollectionConfig = {
  // ...
  admin: {
    components: {
      edit: {
        PreviewButton: '/path/to/MyPreviewButton',
      },
    },
  },
}
Here's an example of a custom PreviewButton component:

Server Component
import React from 'react'
import { PreviewButton } from '@payloadcms/ui'
import type { PreviewButtonServerProps } from 'payload'

export function MyPreviewButton(props: PreviewButtonServerProps) {
  return <PreviewButton />
}
Client Component
'use client'
import React from 'react'
import { PreviewButton } from '@payloadcms/ui'
import type { PreviewButtonClientProps } from 'payload'

export function MyPreviewButton(props: PreviewButtonClientProps) {
  return <PreviewButton />
}
Description
The Description property allows you to render a custom description of the Collection or Global in the Edit View.

To add a Description component, use the components.edit.Description property in your Collection Config or components.elements.Description in your Global Config:

import type { CollectionConfig } from 'payload'

export const MyCollection: CollectionConfig = {
  // ...
  admin: {
    components: {
      Description: '/path/to/MyDescriptionComponent',
    },
  },
}
Note: The Description component is shared between the Edit View and the List View.

Here's an example of a custom Description component:

Server Component
import React from 'react'
import type { ViewDescriptionServerProps } from 'payload'

export function MyDescriptionComponent(props: ViewDescriptionServerProps) {
  return <div>This is a custom description component (Server)</div>
}
Client Component
'use client'
import React from 'react'
import type { ViewDescriptionClientProps } from 'payload'

export function MyDescriptionComponent(props: ViewDescriptionClientProps) {
  return <div>This is a custom description component (Client)</div>
}
Upload
The Upload property allows you to render a custom file upload component in the Edit View.

To add an Upload component, use the components.edit.Upload property in your Collection Config:

import type { CollectionConfig } from 'payload'

export const MyCollection: CollectionConfig = {
  // ...
  admin: {
    components: {
      edit: {
        Upload: '/path/to/MyUploadComponent',
      },
    },
  },
}
Note: The Upload component is only available for Collections.

Here's an example of a custom Upload component:

import React from 'react'

export function MyUploadComponent() {
  return <input type="file" />
}
---
List View
The List View is where users interact with a list of Collection Documents within the Admin Panel. This is where they can view, sort, filter, and paginate their documents to find exactly what they're looking for. This is also where users can perform bulk operations on multiple documents at once, such as deleting, editing, or publishing many.

The List View can be swapped out in its entirety for a Custom View, or it can be injected with a number of Custom Components to add additional functionality or presentational elements without replacing the entire view.

Note: Only Collections have a List View. Globals do not have a List View as they are single documents.

Custom List View
To swap out the entire List View with a Custom View, use the admin.components.views.list property in your Payload Config:

import { buildConfig } from 'payload'

const config = buildConfig({
  // ...
  admin: {
    components: {
      views: {
        list: '/path/to/MyCustomListView',
      },
    },
  },
})
Here is an example of a custom List View:

Server Component
import React from 'react'
import type { ListViewServerProps } from 'payload'
import { DefaultListView } from '@payloadcms/ui'

export function MyCustomServerListView(props: ListViewServerProps) {
  return <div>This is a custom List View (Server)</div>
}
Client Component
'use client'
import React from 'react'
import type { ListViewClientProps } from 'payload'

export function MyCustomClientListView(props: ListViewClientProps) {
  return <div>This is a custom List View (Client)</div>
}
For details on how to build Custom Views, including all available props, see Building Custom Views.

Custom Components
In addition to swapping out the entire List View with a Custom View, you can also override individual components. This allows you to customize specific parts of the List View without swapping out the entire view for your own.

To override List View components for a Collection, use the admin.components property in your Collection Config:

import type { CollectionConfig } from 'payload'

export const MyCollection: CollectionConfig = {
  // ...
  admin: {
    components: {
      // ...
    },
  },
}
The following options are available:

Path

Description

beforeList

An array of custom components to inject before the list of documents in the List View. More details.

beforeListTable

An array of custom components to inject before the table of documents in the List View. More details.

afterList

An array of custom components to inject after the list of documents in the List View. More details.

afterListTable

An array of custom components to inject after the table of documents in the List View. More details.

listMenuItems

An array of components to render within a menu next to the List Controls (after the Columns and Filters options)

Description

A component to render a description of the Collection. More details.

beforeList
The beforeList property allows you to inject custom components before the list of documents in the List View.

To add beforeList components, use the components.beforeList property in your Collection Config:

import type { CollectionConfig } from 'payload'

export const MyCollection: CollectionConfig = {
  // ...
  admin: {
    components: {
      beforeList: ['/path/to/MyBeforeListComponent'],
    },
  },
}
Here's an example of a custom beforeList component:

Server Component
import React from 'react'
import type { BeforeListServerProps } from 'payload'

export function MyBeforeListComponent(props: BeforeListServerProps) {
  return <div>This is a custom beforeList component (Server)</div>
}
Client Component
'use client'
import React from 'react'
import type { BeforeListClientProps } from 'payload'

export function MyBeforeListComponent(props: BeforeListClientProps) {
  return <div>This is a custom beforeList component (Client)</div>
}
beforeListTable
The beforeListTable property allows you to inject custom components before the table of documents in the List View.

To add beforeListTable components, use the components.beforeListTable property in your Collection Config:

import type { CollectionConfig } from 'payload'

export const MyCollection: CollectionConfig = {
  // ...
  admin: {
    components: {
      beforeListTable: ['/path/to/MyBeforeListTableComponent'],
    },
  },
}
Here's an example of a custom beforeListTable component:

Server Component
import React from 'react'
import type { BeforeListTableServerProps } from 'payload'

export function MyBeforeListTableComponent(props: BeforeListTableServerProps) {
  return <div>This is a custom beforeListTable component (Server)</div>
}
Client Component
'use client'
import React from 'react'
import type { BeforeListTableClientProps } from 'payload'

export function MyBeforeListTableComponent(props: BeforeListTableClientProps) {
  return <div>This is a custom beforeListTable component (Client)</div>
}
afterList
The afterList property allows you to inject custom components after the list of documents in the List View.

To add afterList components, use the components.afterList property in your Collection Config:

import type { CollectionConfig } from 'payload'

export const MyCollection: CollectionConfig = {
  // ...
  admin: {
    components: {
      afterList: ['/path/to/MyAfterListComponent'],
    },
  },
}
Here's an example of a custom afterList component:

Server Component
import React from 'react'
import type { AfterListServerProps } from 'payload'

export function MyAfterListComponent(props: AfterListServerProps) {
  return <div>This is a custom afterList component (Server)</div>
}
Client Component
'use client'
import React from 'react'
import type { AfterListClientProps } from 'payload'

export function MyAfterListComponent(props: AfterListClientProps) {
  return <div>This is a custom afterList component (Client)</div>
}
afterListTable
The afterListTable property allows you to inject custom components after the table of documents in the List View.

To add afterListTable components, use the components.afterListTable property in your Collection Config:

import type { CollectionConfig } from 'payload'

export const MyCollection: CollectionConfig = {
  // ...
  admin: {
    components: {
      afterListTable: ['/path/to/MyAfterListTableComponent'],
    },
  },
}
Here's an example of a custom afterListTable component:

Server Component
import React from 'react'
import type { AfterListTableServerProps } from 'payload'

export function MyAfterListTableComponent(props: AfterListTableServerProps) {
  return <div>This is a custom afterListTable component (Server)</div>
}
Client Component
'use client'
import React from 'react'
import type { AfterListTableClientProps } from 'payload'

export function MyAfterListTableComponent(props: AfterListTableClientProps) {
  return <div>This is a custom afterListTable component (Client)</div>
}
Description
The Description property allows you to render a custom description of the Collection in the List View.

To add a Description component, use the components.Description property in your Collection Config:

import type { CollectionConfig } from 'payload'

export const MyCollection: CollectionConfig = {
  // ...
  admin: {
    components: {
      Description: '/path/to/MyDescriptionComponent',
    },
  },
}
Note: The Description component is shared between the List View and the Edit View.

Here's an example of a custom Description component:

Server Component
import React from 'react'
import type { ViewDescriptionServerProps } from 'payload'

export function MyDescriptionComponent(props: ViewDescriptionServerProps) {
  return <div>This is a custom Collection description component (Server)</div>
}
Client Component
'use client'
import React from 'react'
import type { ViewDescriptionClientProps } from 'payload'

export function MyDescriptionComponent(props: ViewDescriptionClientProps) {
  return <div>This is a custom Collection description component (Client)</div>
}